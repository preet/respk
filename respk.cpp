/*
   Copyright (C) 2015 Preet Desai (preet.desai@gmail.com)

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/


#include <vector>
#include <iostream>
#include <fstream>
#include <cstdint>
#include <array>
#include <sstream>

#include "picojson/picojson.h"

std::array<std::string,256> g_lut_ubyte_to_hex;

std::string const g_respk_file_header =
        "/* This file has been automatically generated by respk.\n"
        " * Don't modify it unless you know what you're doing! */\n\n"
        "#include <vector>\n\n";

void BadInput()
{
    std::string const usage =
            "respk: ERROR: Bad arguments: \n"
            "* Pass in the output file with the -o option\n"
            "* Pass in one or more json files describing resources\n"
            "  with the -i option\n"
            "ex: \n"
            "./respk -o /home/user/Dev/build/proj/ -i res/images.json res/audio.json\n";

    std::cout << usage << std::endl;
}

std::string GetFileNameOnly(std::string const &file_path)
{
    size_t last_idx = file_path.find_last_of('/');
    if(last_idx == std::string::npos) {
        last_idx = 0;
    }
    else {
        last_idx++;
    }
    std::string fname_only(file_path,last_idx,file_path.size());

    return fname_only;
}

std::string GetFilePathOnly(std::string const &file_path)
{
    size_t last_idx = file_path.find_last_of('/');
    std::string fpath_only;
    if(last_idx != std::string::npos) {
        fpath_only = std::string(file_path,0,last_idx);
        fpath_only.append("/");
    }

    return fpath_only;
}

bool GenerateDataOutputFromFile(std::string const &res_name,
                                std::string const &json_file_path,
                                std::string const &res_file_path,
                                std::string &output)
{
    // Try a relative path first
    std::string const json_fpath_only = GetFilePathOnly(json_file_path);

    std::ifstream res_file(
                json_fpath_only+res_file_path,
                std::ios_base::in | std::ios_base::binary);

    if(!res_file) {
        // Couldn't find the resource file. Try the
        // given file path directly
        res_file.close();
        res_file.open(res_file_path,
                      std::ios_base::in | std::ios_base::binary);

        if(!res_file) {
            std::cout << "respk: ERROR: Could not open resource file: " << std::endl;
            std::cout << "Tried: " << std::endl;
            std::cout << res_file_path << " and " << std::endl;
            std::cout << (json_fpath_only+res_file_path) << std::endl;
            return false;
        }
    }

    std::istreambuf_iterator<char> res_file_it(res_file);
    std::istreambuf_iterator<char> res_file_eos;
    std::vector<char> list_bytes(res_file_it,res_file_eos);

    output.clear();
    output.append("\n");
    output.append("// ============================================================= // \n\n");
    output.append("extern std::vector<unsigned char> const ");
    output.append(res_name);
    output.append(" =\n");
    output.append("{\n    ");

    unsigned char* list_ubytes =
            reinterpret_cast<unsigned char*>(&(list_bytes[0]));

    // output all the bytes
    for(size_t i=0; i < list_bytes.size()-1; i++) {
        output.append(g_lut_ubyte_to_hex[list_ubytes[i]] + ",");
        if((i+1)%16==0) {
            output.append("\n    ");
        }
    }
    // last byte
    output.append(g_lut_ubyte_to_hex[list_ubytes[list_bytes.size()-1]]);
    output.append("\n};\n");

    return true;
}

bool GenerateSourceFromResourceDesc(std::string const &input_path,
                                    std::string &output_source)
{
    std::ifstream input_file(input_path);
    if(!input_file) {
        std::cout << "respk: ERROR: Could not open file "
                  << input_path << std::endl;
        return false;
    }

    picojson::value json_root_val;
    std::string err = picojson::parse(json_root_val,input_file);
    if(!err.empty()) {
        std::cout << "respk: ERROR: Could not parse json: " << std::endl;
        std::cout << err << std::endl;
        return false;
    }

    // Check that the file has a root object
    if(!json_root_val.is<picojson::object>()) {
        std::cout << "respk: ERROR: JSON is not an object " << std::endl;
        std::cout << input_path << std::endl;
        return false;
    }

    // Objects are <string,value> maps
    picojson::object const &root_obj =
            json_root_val.get<picojson::object>();

    // resources
    std::map<std::string,std::string> cpp_list_resources;
    auto resources_it = root_obj.find("resources");
    if(resources_it == root_obj.end()) {
        std::cout << "respk: ERROR: json does not contain "
                     "a \"resources\" entry" << std::endl;
        return false;
    }
    else {
        if(!resources_it->second.is<picojson::array>()) {
            std::cout << "respk: ERROR: resources value "
                         "must be an array" << std::endl;
            return false;
        }
        else {
            // iterate through resources
            int res_idx=0;
            auto const &res_array =
                    resources_it->second.get<picojson::array>();

            for(auto res_value_it = res_array.begin();
                res_value_it != res_array.end();
                ++res_value_it)
            {
                // ensure each resource is an object
                if(!res_value_it->is<picojson::object>()) {
                    std::cout << "respk: ERROR: resource must "
                                 "be an object" << std::endl;
                }
                else {
                    auto const &res_obj = res_value_it->get<picojson::object>();
                    auto res_name_it = res_obj.find("name");
                    auto res_path_it = res_obj.find("path");
                    if(res_name_it == res_obj.end()) {
                        std::cout << "respk: ERROR: resource " << res_idx
                                  << "missing name" << std::endl;
                        return false;
                    }
                    if(res_path_it == res_obj.end()) {
                        std::cout << "respk: ERROR: resource " << res_idx
                                  << "missing path" << std::endl;
                        return false;
                    }

                    if(!res_name_it->second.is<std::string>()) {
                        std::cout << "respk: ERROR: resource name " << res_idx
                                  << " must be a string" << std::endl;
                        return false;
                    }
                    if(!res_path_it->second.is<std::string>()) {
                        std::cout << "respk: ERROR: resource path " << res_idx
                                  << " must be a string" << std::endl;
                        return false;
                    }

                    cpp_list_resources.emplace(
                                res_name_it->second.get<std::string>(),
                                res_path_it->second.get<std::string>());
                }

                res_idx++;
            }
        }
    }

    // prepend
    std::string cpp_prepend;
    auto prepend_it = root_obj.find("prepend");
    if(prepend_it != root_obj.end()) {
        if(!prepend_it->second.is<std::string>()) {
            std::cout << "respk: ERROR: prepend value must be a string" << std::endl;
            return false;
        }
        else {
            cpp_prepend = prepend_it->second.get<std::string>();
        }
    }

    // append
    std::string cpp_append;
    auto append_it = root_obj.find("append");
    if(append_it != root_obj.end()) {
        if(!append_it->second.is<std::string>()) {
            std::cout << "respk: ERROR: append value must be a string" << std::endl;
            return false;
        }
        else {
            cpp_append = append_it->second.get<std::string>();
        }
    }

    // save data to file
    output_source.append(cpp_prepend);
    output_source.append("\n");

    for(auto & res : cpp_list_resources) {
        std::string res_data;
        if(!GenerateDataOutputFromFile(res.first,
                                       input_path,
                                       res.second,
                                       res_data))
        {
            return false;
        }
        output_source.append(res_data);
    }
    output_source.append("\n");
    output_source.append(cpp_append);
    output_source.append("\n\n\n");

    return true;
}

int main(int argc, char *argv[])
{
    // Process args
    std::string output;
    std::vector<std::string> list_inputs;

    bool capture_inputs=false;
    bool capture_output=false;

    for(int i=1; i < argc; i++) {
        std::string const arg(argv[i]);
        if(arg == "-i") {
            capture_inputs = true;
            capture_output = false;
            continue;
        }
        else if(arg == "-o") {
            capture_inputs = false;
            capture_output = true;
            continue;
        }

        if(capture_inputs) {
            list_inputs.push_back(arg);
        }
        else if(capture_output) {
            output = arg;
        }
    }

    if(output.empty() || list_inputs.empty()) {
        BadInput();
        return -1;
    }

    // Populate the LUT to convert ubytes to string rep
    for(size_t i=0; i < g_lut_ubyte_to_hex.size(); i++) {
        std::stringstream ss_to_hex;
        ss_to_hex << std::hex << i;
        g_lut_ubyte_to_hex[i] = std::string("0x"+ss_to_hex.str());
    }

    std::string cpp_source;
    cpp_source.append(g_respk_file_header);

    for(auto const &input : list_inputs) {
        if(!GenerateSourceFromResourceDesc(input,cpp_source)) {
            return -1;
        }
    }

    // Create the source file
    std::ofstream cpp_file;
    cpp_file.open(output);
    if(!cpp_file) {
        std::cout << "respk: ERROR: failed to open output file: " << std::endl;
        std::cout << output << std::endl;
        return -1;
    }

    cpp_file << cpp_source;
    cpp_file.close();

    return 0;
}

